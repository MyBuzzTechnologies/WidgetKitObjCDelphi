# Delphi-Swift Library Interop Tutorial (Advanced)

The project in this repo demonstrates a working Delphi 13 project which uses a custom created native Objective C framework to wrap the WidgetKit native swift framework so that it can be used by Delphi.

Delphi doesn't natively support importing and using Swift-only frameworks within a Delphi app.

However, it DOES support native Objective-C frameworks and mixed Objective C+Swift frameworks. The latter is what this project and instructions are about.

## Sample Project Outline

The project repo contains 2 folders:

- WidgetKitDelphi -- a Delphi 13 project that consumes (and includes) the custom framework
- WidgetKitObjC - the native XCode framework project that is consumed by the Delphi project.

Note: the project was built with XCode 26.1 and Delphi 13.0 but may work with earlier versions.

### WidgetKitDelphi

This project has a few key things to note:

- The Frameworks folder contains the actual custom framework as generated by the XCode project. This is currently the debug build (which works fine) but can be the release build of the framework, recommended before you deploy to production.

- I used the excellent [Grijjy DeployMan.exe](https://github.com/grijjy/GrijjyDeployMan) to manage the deployment of the Delphi project. This is a lot easier than manually adding all files from the framework into the project manually. The .grdeploy file is included in case you want to see how this works.

- The iOSapi.WidgetKitObjC.pas file is generated by [Octoid](https://github.com/Embarcadero/octoid) from the framework

### WidgetKitObjC

This uses the mixed-mode version of a custom framework to include Swift libraries (and code) in an Objective C framework.
This is the only configuration that will work!

If you need to rebuild the custom framework and include in the Delphi project (to replace the one from this repo):

1. Open the XCode and build it.
2. Then click Project (menu) > "Show Build Folder In Finder" to see where the framework is generated.
3. Navigate through Products > Debug-iphoneos
4. Copy the _Entire_ .framework folder into the Frameworks folder in the Delphi project to replace any existing folder. Make sure to delete the existing folder first so nothing is left behind that may confuse the project.

## How-To From Scratch Instructions

Note: the instructions below refer to XCode 26.1 and Delphi 13. If you use earlier versions of each, you should be able to do what is described but the menu options may be called something different.

## In XCode

### 1. Create an Objective C Framework project in XCode

- File menu > NEW > PROJECT
- Select "iOS" from the top platform options. DO NOT USE MULTIPLATFORM!
- Select "Framework"
- Click NEXT

- Type a Project Name. This will become the name of your framework when exported so make it relevant. _E.g. WidgetKitObjC_ (i.e. the swift library name being wrapped + ObjC)
- MOST IMPORTANT! Choose "Objective C" as the Language
- Type an Organisation Identifier. Usually this will be match the prefix you'll be using for your Delphi app, especially if you plan to use App Groups to share data etc.
- All other options can be left as default

- Click NEXT
- Choose a location for your XCode project to be stored
- Click to create the project

### 2. Add your swift library (the one you're wrapping) to the XCode project

- In the file navigator (first panel in the left pane) click the root node to see the project options
- In "General", under "Frameworks and Libraries" click the + button
- Select your framework to add it
- After adding, make sure it is set to "Do Not Embed" in the Embed column
- Make sure you set the Minimum Deployments version to match the min version supported by the Swift library you're wrapping

### 3. Add your Swift sources

This part is completely up to you, and depends on your swift library.

The concept is:

- you need to write a Swift class that "uses" the relevant Swift library functions, then exposes the result from the function. This can be a very thin wrapper (i.e. a straight 1-2-1 mapping) which may seem odd, but allows us to mark these as exposed for Objective C, which is basically what Apple hasn't done (and why we're doing this).

E.g.:

- Add a new Swift file to the project called "WidgetCenterBridge.swift"
- Fill the source as shown below:

```swift
import Foundation
import WidgetKit

@available(iOS 14.0, *)
@objcMembers
public final class WidgetCenterBridge: NSObject {

    /// Reload all timelines for all widget kinds
    public static func reloadAllTimelines() {
        #if canImport(WidgetKit)
        WidgetCenter.shared.reloadAllTimelines()
        #endif
    }

    /// Reload timelines for a specific widget kind
    public static func reloadTimelines(ofKind kind: String) {
        #if canImport(WidgetKit)
        WidgetCenter.shared.reloadTimelines(ofKind: kind)
        #endif
    }
}
```

Note that the methods here are wrapped with **canImport()** to make sure the WidgetKit library is available, and the whole class is wrapped in an **@available()** so the class isn't available to iOS versions lower than WidgetKit supports.

**Important Note**

You need to MARK the class with a **@objcMembers** decorator as shown above so that XCode automatically makes this custom swift class visible to Objective C code (needed later).

The class MUST inherit from **NSObject** or the swift generator won't export it.

All class methods we want to make available to Objective C and be **public** or **open** otherwise they can't be used.

Notice how in the above code, the methods just call the equivalent methods of the WidgetKit swift library, and uses the same names and parameters. This is absolutely fine.

You can of course add other custom code, checks etc if you want to, or even write more complex custom methods to perform custom actions using the swift libraries. It's up to you.

See the tips section at the end of this ReadMe for tips that may help if you're having issues.

### 4. Add an Objective C Wrapper

Once your custom Swift class is written and exposed with @objMembers and public, you need to write an Objective C class that consumes this and exposes so that Delphi can pick it up.

Again - this is a very thin wrapper class, which is correct.

- Create a new **Objective C class file** (.m)
- Create a new **Objective C header file** (.h) with the same name, so you have a pair

Write your class and header interface in Objective C into these files.

E.g.:

WidgetKitObjCWrapper.h

```objectivec
#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

API_AVAILABLE(ios(14.0))
@interface WidgetKitObjCWrapper : NSObject

+ (void)reloadAllTimelines;
+ (void)reloadTimelinesOfKind:(NSString *)kind;

@end

NS_ASSUME_NONNULL_END
```

WidgetKitObjCWrapper.m

```objectivec
#import <Foundation/Foundation.h>
#import "WidgetKitObjCWrapper.h"
#import <WidgetKitObjC/WidgetKitObjC-Swift.h>

@implementation WidgetKitObjCWrapper

+ (void)reloadAllTimelines {
    if (@available(iOS 14.0, *)) {
        [WidgetCenterBridge reloadAllTimelines];
    }
}

+ (void)reloadTimelinesOfKind:(NSString *)kind {
    if (@available(iOS 14.0, *)) {
        [WidgetCenterBridge reloadTimelinesOfKind:kind];
    }
}

@end
```

See [this document](https://developer.apple.com/documentation/swift/importing-swift-into-objective-c) for how to write interoperable code.

Tip: the strangest part is the import for ...-Swift.h>. You won't see this in your project tree, as it's auto-generated but will be the same name as your custom Swift file with -Swift suffix, and contains the Objective C version of your Swift class so it can be used in this class.

Note: Make sure to add the API_AVAILABLE() and @available() wrappings as shown above if your wrapped Swift framework needs them (same as you did in the custom Swift class file).

### 5. Make the new Objective C class visible (VERY IMPORTANT)

I missed this final point the first few times I tried to get this working. And it's so important! If you miss this step, the generated Delphi header file won't include the class you've spent time writing.

- Click on the root node of the project to see the project settings panes
- Click the .h file for your custom Objective C class
- If you don't have the right-hand pane open in XCode, expand it with the button in the top-right of the IDE
- DOUBLE-CLICK on the toolbox icon in the **Target Membership** area to edit it
- Change the visibility to **Public** (it's likely to be "Project", but this is wrong)

### 6. Add a reference to this .h file to the umbrella header file

When you first created the project there will have been a default .h file created matching the name of your framework.

Edit this file and add an #import line for your Objective C header file (the one you just made public).

E.g. #import <WidgetKitObjC/WidgetKitObjCWrapper.h>

Do this at the bottom.

### 6. Build and see what happens!

Build it. Any errors, fix them.

Once successful, find the built framework so you can pull it into your Delphi project.

**Product** menu > **Show Build Folder In Finder**

Navigate through Products > Debug-iphoneos to get to the .framework folder.

**NOTE:** you will need this folder in its entirety, so make sure you copy the entire thing when instructed in the next section of these instructions.

## In Delphi

Now, how do you actually use this custom framework in Delphi?

Fundamentally it follows these steps:

1. Create your Delphi project so you have somewhere to put things

2. Copy the custom framework into your SDK folder so Octoid can import it

3. Use [Octoid](https://github.com/Embarcadero/octoid) to generate a header file for your custom framework

4. Create your project, which involves some project and linker config, importing the custom framework into the Deployment for the project, importing the newly generated header file from step 2 and voila.

I'll expand on all these below:

### 1. Create a Delphi project (Firemonkey)

A simple one - just create an FMX app (or use an existing one).

### 2. Copy the framework and generate Delphi headers for it

- Create a folder in the Delphi source folder called **Frameworks**
- Copy the .framework folder from the build folder of XCode into the newly created folder
- You also need to copy the .framework folder into the SDK folder for the iOS version you've imported into Delphi.
  This is usually:

```
<your Documents folder>\Embarcadero\Studio\SDKs\iPhoneOS???.sdk\System\Library\Frameworks

e.g.

C:\Users\<username>\Documents\Embarcadero\Studio\SDKs\iPhoneOS26.0.sdk\System\Library\Frameworks
```

### 3. Use Octoid to generate a header file

- Clone the repo for [Octoid](https://github.com/Embarcadero/octoid), open the Octoid project in Delphi and build according to the instructions for the Desktop app.

- Use Octoid to import your new framework. It will appear in the list of SDK Frameworks in Octoid if you've copied it into the correct location.

**Note:** I don't provide support for getting Octoid working. If you have questions or need help getting the .exe built, speak to the project owner.

- Copy the iOSapi.?????.pas file it generates into your Delphi project.

**How do you know it's correct?** - Simple, just open the generated file and make sure your Objective C class you created in the framework is shown. If so, it's good.

### 3.1. Edit the generated header file with lazy loading

There are a few ways to do this, but what I described below works for me every time...

- Edit the generated iOSapi.?????.pas file (in Delphi if already imported into your project)
- Remove everything from the **implementation** section as it isn't needed (but leave the "implementation" keyword or the unit won't compile).
- Remove the const and the function directly above the "implementation" keyword.

```
e.g.
--> remove these:

-- function WidgetKitObjCVersionNumber: Double;
-- // Exported const WidgetKitObjCVersionString has an unsupported type: const unsigned char []

-- const
--   libWidgetKitObjC = '/System/Library/Frameworks/WidgetKitObjC.framework/WidgetKitObjC';
```

- Directly BELOW the implementation keyword, add a lazy loader similar to the example below, replacing the name of the WidgetKitObjC with the name of your framework:

```
procedure <Framework Name>Loader; cdecl; external framework '<Framework Name>';

e.g.

procedure WidgetKitObjCLoader; cdecl; external framework 'WidgetKitObjC';
```

Note, do NOT include the .framework extension in the name.

**Why do this?**

Delphi can auto-link frameworks but they need to be referenced in the sources somewhere, even if not actually used.
The simplest way is as shown below with a "lazy loader" reference. This is simple a procedure reference that is never used (so can have any time you like), as ong as it has the "external framework 'framework name';" part.

### 4. Project Options and Deployment

Now, you need to hook all this up as follows:

1. Make sure your Delphi IDE has imported the standard Swift libraries, as you'll likely need them.

See this article for how to do this:
https://github.com/DelphiWorlds/HowTo/tree/main/Solutions/AddSwiftSupport

**1. Add a linker option:**

- In your Project Options > Delphi Compiler > Linking > Options passed to the LD Linker

```
-no_fixup_chains -ObjC -rpath /usr/lib/swift -rpath @loader_path/Frameworks
```

**Note:** technically you may not need the "-rpath /usr/lib/swift" reference, however, its a safe bet that as you're wrapping a Swift library (the whole point of this exercise), it's likely to reference one of the other standard Swift libraries.
By including the above, the linker will be able to find any dependencies.

**2. Reference the custom framework folder**

This is the folder in your own Delphi project where you copied your custom framework earlier.

Project Options > Delphi Compiler

Set **Framework search path** to include "..\Frameworks"

**3. Include the custom framework in your Delphi Project deployment**

In your project, under **Project** > **Deployment**, you need to add every item from inside the .framework folder for your custom framework.

Note: the **Remote Path** for each must have the same relative folder structure as the parent. E.g.:

```
Local Path:
Frameworks\WidgetKitObjC.framework\

Local File Name:
Info.plist

Remote Dir:
.\Frameworks\WidgetKitObjC.framework

Remote File Name:
Info.plist
```

The main thing is that the Remote Dir MUST start with ".\Framework\...."

**4. Write some Delphi code!**

At this point you will be able to use the imported classes from your custom framework in your Delphi app.

e.g.

```delphi
TWidgetKitObjCWrapper.OCClass.reloadAllTimelines;
```

**5. Done**

At this point, you should be able to build and run your app.

If the app runs without crashing, the custom framework has been found and linked correctly!

## Problem Solving

There are lots of things that could go wrong but if you follow the instructions, you should be ok.
Below are the most common issues I found with advice on how to find a solution.

### When trying to build my framework in XCode, I see CLang errors saying it can't find one or more modules which are there

This is one of those generic errors telling you what the linker failed on, not what caused it.
In this case, it likely means that you're referring to the -swift.h bridge file in another .h file of your project.

The -swift file is a generated one. Because of this, it won't be available to the other header files depending on the build order. You can import it into the .m files, but not the .h files.

You will need to restructure your code so you don't need the import in your .h file anymore.

### After doing everything above, my Delphi app crashes when opened

This is most likely to be because the Framework (your custom one) can't be found by the app at runtime.

Note: just because it links ok, doesn't mean it will run ok!

- Missing Linker Options (make sure you pass the relative path to your framework folder into the Options To Be Passed To The Linker in your project options)
- The custom framework isn't correct or has been copied incorrectly from the XCode build location

### Delphi fails with Linker errors during the Linking phase of the build

- Have you edited the iOSapi.?????.pas file to include the lazy loader procedure? If not, the linker won't be able to find it.
- Check the lazy loader line has the correct framework name. This must match the ????.framework dolder name (without the .framework extension)

## Tips that may help

### Looking at the generated Objective C classes of your bridge Swift class

XCode will automatically create a swift header file for you which you can take a look at to check whether your swift class has exported what you expected to Objective C or not.
This file will be generated in your build folder. Usually something like:
```
~/Library/Developer/Xcode/DerivedData/<project name>-eyqisrfcxmibozcdntjoexyykzye/Index.noindex/Build/Products/Debug-iphoneos/<Framework Name>.framework/Headers/<FrameworkName>-Swift.h
```
If you open this file in XCode and scroll down to the bottom, you will see details for each exported class so you can check.
For example:
```
SWIFT_CLASS("_TtC20DeclaredAgeRangeObjC22DeclaredAgeRangeBridge") SWIFT_AVAILABILITY(ios,introduced=26.0)
@interface DeclaredAgeRangeBridge : NSObject
+ (void)fetchAgeRangeWithMinimumAge:(NSInteger)minimumAge maximumAge:(NSInteger)maximumAge vc:(UIViewController * _Nonnull)vc completion:(void (^ _Nonnull)(DeclaredAgeRangeResponse * _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end
```
If you can't find your class mentioned in this file, there are a few potential causes:

1. Your class doesn't inherit from the NSObject class
2. You missed added the @objcMembers decorator above the class declaration
3. Your class is not marked as **public**

If your class is being exported into the -swift bridge file, but you're missing one or more methods or properties:

1. Make sure the method or property is marked as public (even if also marked static)
2. You can try adding @objc decorator to the method or property header to see if that helps (e.g. @objc static public let myConstant = 4)
3. One or more types used by that property or in the parameters of that method aren't available for Objective C.

With regard to #3, this is something I hit a few times.

Swift has enums, but Objective C doesn't. If you use parameters or a return type which is an Enum, it won't be exported to the bridge file.
You will need to find another option - e.g. using Int value equivalents.

I hope this helps!
